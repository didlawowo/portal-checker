version: '3'

silent: true

# ğŸ¯ Variables globales
vars:
  APP_NAME: portal-checker
  NAMESPACE: kube-infra
  DOCKER_REGISTRY: fizzbuzz2
  IMAGE_TAG:
    sh: git rev-parse --short HEAD
  HELM_CHART_PATH: ./helm
  CONFIG_DIR: ./config

# ğŸš€ TÃ¢ches principales
tasks:

  # ğŸ“¦ Construction et dÃ©ploiement
  build:
    desc: "ğŸ”¨ Construire l'image Docker"
    cmds:
    - docker build -t {{.DOCKER_REGISTRY}}/{{.APP_NAME}}:{{.IMAGE_TAG}} .
    - docker build -t {{.DOCKER_REGISTRY}}/{{.APP_NAME}}:latest .
    sources:
    - Dockerfile
    - app.py
    - requirements.txt
    - templates/**/*
    - static/**/*

  push:
    desc: "ğŸ“¤ Pousser l'image vers le registry"
    deps: [ build ]
    cmds:
    - docker push {{.DOCKER_REGISTRY}}/{{.APP_NAME}}:{{.IMAGE_TAG}}
    - docker push {{.DOCKER_REGISTRY}}/{{.APP_NAME}}:latest

  # ğŸ›ï¸ Gestion Helm
  helm-template:
    desc: "ğŸ“‹ Afficher le template Helm gÃ©nÃ©rÃ©"
    cmds:
    - helm template {{.APP_NAME}} {{.HELM_CHART_PATH}} --namespace {{.NAMESPACE}}

  helm-dry-run:
    desc: "ğŸ§ª Test Ã  sec du dÃ©ploiement Helm"
    cmds:
    - helm upgrade --install {{.APP_NAME}} {{.HELM_CHART_PATH}} --namespace {{.NAMESPACE}} --create-namespace --dry-run --debug

  helm-install:
    desc: "ğŸš€ DÃ©ployer avec Helm"
    cmds:
    - helm upgrade --install {{.APP_NAME}} {{.HELM_CHART_PATH}} --namespace {{.NAMESPACE}} --create-namespace --set image.tag={{.IMAGE_TAG}}

  helm-install-docker:
    desc: "ğŸ³ DÃ©ployer avec Helm + valeurs Docker (branch)"
    cmds:
    - helm upgrade --install {{.APP_NAME}}-dev {{.HELM_CHART_PATH}} --namespace {{.NAMESPACE}}-dev --create-namespace --values {{.HELM_CHART_PATH}}/values.yaml --values {{.HELM_CHART_PATH}}/values/docker.yaml

  # ğŸ” Validation et tests
  validate-yaml:
    desc: "âœ… Valider les fichiers YAML de configuration"
    cmds:
    - |
      echo "ğŸ” Validation des fichiers YAML..."
      python -c "
      import yaml
      import sys

      files = ['{{.CONFIG_DIR}}/excluded-urls.yaml', '{{.CONFIG_DIR}}/urls.yaml']
      for file in files:
          try:
              with open(file, 'r') as f:
                  data = yaml.safe_load(f)
                  if isinstance(data, list):
                      print(f'âœ… {file}: Format valide ({len(data)} entrÃ©es)')
                  else:
                      print(f'âŒ {file}: Format incorrect (attendu: liste)')
                      sys.exit(1)
          except FileNotFoundError:
              print(f'âš ï¸  {file}: Fichier non trouvÃ©')
          except Exception as e:
              print(f'âŒ {file}: Erreur - {e}')
              sys.exit(1)
      "
  
  test:
    desc: "ğŸ§ª ExÃ©cuter les tests avec pytest"
    cmds:
    - uv run --extra dev pytest tests/ -v

  test-coverage:
    desc: "ğŸ“Š ExÃ©cuter les tests avec couverture de code"
    cmds:
    - uv run --extra dev pytest tests/ --cov=. --cov-report=term-missing --cov-report=html -v
    - echo "ğŸ“Š Rapport de couverture gÃ©nÃ©rÃ© dans htmlcov/"

  test-exclusions:
    desc: "ğŸ§ª Tester la logique d'exclusion des URLs"
    cmds:
    - |
      python -c "
      import sys
      sys.path.append('.')
      from app import _is_url_excluded, load_excluded_urls

      # Charger les exclusions
      excluded_urls = load_excluded_urls()
      print(f'ğŸ“Š {len(excluded_urls)} URLs d\'exclusion chargÃ©es')

      # Tests
      test_cases = [
          ('monitoring.example.com/', True),
          ('test.internal/api', True), 
          ('infisical.dc-tech.work/ss-webhook', True),
          ('normal.dc-tech.work/', False),
          ('grafana.dc-tech.work/metrics', True)
      ]

      for url, should_exclude in test_cases:
          result = _is_url_excluded(url)
          status = 'âœ…' if result == should_exclude else 'âŒ'
          print(f'{status} {url} -> Exclu: {result} (attendu: {should_exclude})')
      "

  # ğŸ”§ DÃ©veloppement
  run-dev:
    desc: "ğŸ”§ DÃ©marrer en mode dÃ©veloppement"
    cmds:
    - export FLASK_ENV=development && python app.py --port 5001
    env:
      FLASK_ENV: development
      LOG_LEVEL: DEBUG
      AUTO_REFRESH_ON_START: "true"
      PORT: "5001"

  logs:
    desc: "ğŸ“œ Afficher les logs de l'application"
    cmds:
    - kubectl logs -f deployment/{{.APP_NAME}} -n {{.NAMESPACE}}

  # ğŸ§¹ Maintenance
  clean:
    desc: "ğŸ§¹ Nettoyer les ressources Docker"
    cmds:
    - docker system prune -f
    - docker image prune -f

  restart:
    desc: "ğŸ”„ RedÃ©marrer l'application"
    cmds:
    - kubectl rollout restart deployment/{{.APP_NAME}} -n {{.NAMESPACE}}
    - kubectl rollout status deployment/{{.APP_NAME}} -n {{.NAMESPACE}}

  # ğŸ“Š Monitoring et debug
  status:
    desc: "ğŸ“Š Afficher le statut de l'application"
    cmds:
    - echo "ğŸ” Statut du dÃ©ploiement..."
    - kubectl get pods,svc,ing -n {{.NAMESPACE}}
    - echo ""
    - echo "ğŸ”§ Configuration actuelle..."
    - kubectl get configmap {{.APP_NAME}}-config -n {{.NAMESPACE}} -o yaml

  port-forward:
    desc: "ğŸŒ Redirection de port pour accÃ¨s local"
    cmds:
    - kubectl port-forward svc/{{.APP_NAME}} 8080:80 -n {{.NAMESPACE}}

  shell:
    desc: "ğŸš Shell interactif dans le pod"
    cmds:
    - kubectl exec -it deployment/{{.APP_NAME}} -n {{.NAMESPACE}} -- /bin/sh

  # ğŸ”„ Refresh et configuration
  refresh-urls:
    desc: "ğŸ”„ Forcer le refresh des URLs via l'API"
    cmds:
    - |
      echo "ğŸ”„ Refresh des URLs..."
      POD=$(kubectl get pods -n {{.NAMESPACE}} -l app.kubernetes.io/name={{.APP_NAME}} --field-selector=status.phase=Running -o jsonpath='{.items[0].metadata.name}')
      kubectl exec $POD -n {{.NAMESPACE}} -- curl -s http://localhost:5000/refresh
      echo "âœ… Refresh terminÃ©"

  # ğŸ“Š Memory monitoring
  memory-check:
    desc: "ğŸ“Š VÃ©rifier l'usage mÃ©moire des pods"
    cmds:
    - |
      echo "ğŸ“Š Usage mÃ©moire pour {{.APP_NAME}}..."
      kubectl top pods -n {{.NAMESPACE}} -l app.kubernetes.io/name={{.APP_NAME}} 2>/dev/null || echo "âš ï¸ Metrics server non disponible"
      echo ""
      echo "ğŸ“Š MÃ©moire application via endpoint /memory:"
      POD=$(kubectl get pods -n {{.NAMESPACE}} -l app.kubernetes.io/name={{.APP_NAME}} --field-selector=status.phase=Running -o jsonpath='{.items[0].metadata.name}')
      kubectl exec $POD -n {{.NAMESPACE}} -- curl -s http://localhost:5000/memory

  memory-profile:
    desc: "ğŸ” Profiler l'usage mÃ©moire pendant le test d'URLs"
    cmds:
    - |
      echo "ğŸ” DÃ©marrage du profiling mÃ©moire..."
      POD=$(kubectl get pods -n {{.NAMESPACE}} -l app.kubernetes.io/name={{.APP_NAME}} --field-selector=status.phase=Running -o jsonpath='{.items[0].metadata.name}')
      echo "ğŸ“Š MÃ©moire avant refresh:"
      kubectl exec $POD -n {{.NAMESPACE}} -- curl -s http://localhost:5000/memory
      echo ""
      echo "ğŸ”„ Lancement du refresh..."
      kubectl exec $POD -n {{.NAMESPACE}} -- curl -s http://localhost:5000/refresh > /dev/null
      sleep 5
      echo "ğŸ“Š MÃ©moire aprÃ¨s refresh:"
      kubectl exec $POD -n {{.NAMESPACE}} -- curl -s http://localhost:5000/memory

  memory-stress-test:
    desc: "âš¡ Test de stress mÃ©moire avec requÃªtes multiples"
    cmds:
    - |
      echo "âš¡ Test de stress mÃ©moire..."
      POD=$(kubectl get pods -n {{.NAMESPACE}} -l app.kubernetes.io/name={{.APP_NAME}} --field-selector=status.phase=Running -o jsonpath='{.items[0].metadata.name}')
      echo "ğŸ“Š MÃ©moire initiale:"
      kubectl exec $POD -n {{.NAMESPACE}} -- curl -s http://localhost:5000/memory
      echo ""
      echo "ğŸ”„ Lancement de 5 refresh simultanÃ©s..."
      for i in {1..5}; do
        kubectl exec $POD -n {{.NAMESPACE}} -- curl -s http://localhost:5000/refresh > /dev/null &
      done
      wait
      sleep 3
      echo "ğŸ“Š MÃ©moire aprÃ¨s stress test:"
      kubectl exec $POD -n {{.NAMESPACE}} -- curl -s http://localhost:5000/memory

  cache-status:
    desc: "ğŸ’¾ VÃ©rifier le statut du cache"
    cmds:
    - |
      echo "ğŸ’¾ Statut du cache..."
      CACHE_STATUS=$(curl -s http://localhost:5001/cache)
      echo "$CACHE_STATUS"
      
      # VÃ©rifier s'il y a des problÃ¨mes
      if echo "$CACHE_STATUS" | grep -q '"health": "warning"'; then
        echo "âš ï¸ ATTENTION: ProblÃ¨mes dÃ©tectÃ©s dans le cache!"
        echo "$CACHE_STATUS" | grep -o '"issues": \[[^]]*\]'
      else
        echo "âœ… Cache fonctionne correctement"
      fi

  cache-force-refresh:
    desc: "ğŸ”„ Forcer un refresh immÃ©diat du cache"
    cmds:
    - |
      echo "ğŸ”„ Force refresh du cache..."
      curl -X POST -s http://localhost:5001/cache/force-refresh

  cache-clear:
    desc: "ğŸ—‘ï¸ Vider le cache pour debugging"
    cmds:
    - |
      echo "ğŸ—‘ï¸ Suppression du cache..."
      curl -X POST -s http://localhost:5001/cache/clear

  cpu-optimization-check:
    desc: "âš¡ VÃ©rifier l'efficacitÃ© des optimisations CPU"
    cmds:
    - |
      echo "âš¡ VÃ©rification des optimisations CPU..."
      POD=$(kubectl get pods -n {{.NAMESPACE}} -l app.kubernetes.io/name={{.APP_NAME}} --field-selector=status.phase=Running -o jsonpath='{.items[0].metadata.name}')
      echo "ğŸ’¾ Cache status:"
      kubectl exec $POD -n {{.NAMESPACE}} -- curl -s http://localhost:5000/cache
      echo ""
      echo "ğŸ“Š Memory usage:"
      kubectl exec $POD -n {{.NAMESPACE}} -- curl -s http://localhost:5000/memory
      echo ""
      echo "ğŸ” Pod resource usage:"
      kubectl top pod $POD -n {{.NAMESPACE}} 2>/dev/null || echo "âš ï¸ Metrics server non disponible"

  update-exclusions:
    desc: "ğŸ“ Mettre Ã  jour les URLs d'exclusion et redÃ©ployer"
    cmds:
    - task: validate-yaml
    - task: helm-dry-run
    - task: deploy
    - task: restart
    - echo "âœ… URLs d'exclusion mises Ã  jour et application redÃ©ployÃ©e"

  # ğŸ¯ Workflows complets
  deploy-full:
    desc: "ğŸš€ Workflow complet: build + push + deploy"
    cmds:
    - task: validate-yaml
    - task: build
    - task: push
    - task: deploy
    - task: status
    - echo "ğŸ‰ DÃ©ploiement complet terminÃ©!"

  ci-test:
    desc: "ğŸ§ª Tests pour CI/CD"
    cmds:
    - task: validate-yaml
    - task: test-coverage
    - task: test-exclusions
    - task: helm-template
    - echo "âœ… Tous les tests CI passÃ©s"

# ğŸ“ Documentation des tÃ¢ches disponibles
  default:
    desc: "ğŸ“‹ Afficher l'aide"
    cmds:
    - |
      echo "ğŸ¯ Portal Checker - TÃ¢ches disponibles:"
      echo ""
      echo "ğŸ“¦ Construction et dÃ©ploiement:"
      echo "  task build          - Construire l'image Docker"
      echo "  task push           - Pousser vers le registry"
      echo "  task deploy         - DÃ©ployer avec Helm"
      echo "  task deploy-full    - Workflow complet"
      echo ""
      echo "ğŸ” Validation et tests:"
      echo "  task validate-yaml  - Valider les fichiers YAML"
      echo "  task test           - ExÃ©cuter les tests"
      echo "  task test-coverage  - Tests avec couverture de code"
      echo "  task test-exclusions - Tester la logique d'exclusion"
      echo "  task ci-test        - Tests pour CI/CD"
      echo ""
      echo "ğŸ”§ DÃ©veloppement:"
      echo "  task dev            - Mode dÃ©veloppement"
      echo "  task logs           - Afficher les logs"
      echo "  task status         - Statut de l'application"
      echo "  task port-forward   - Redirection de port"
      echo ""
      echo "ğŸ”„ Maintenance:"
      echo "  task refresh-urls   - Forcer refresh des URLs"
      echo "  task update-exclusions - Mettre Ã  jour les exclusions"
      echo "  task restart        - RedÃ©marrer l'application"
      echo "  task clean          - Nettoyer Docker"
      echo ""
      echo "ğŸ“Š Monitoring et optimisations:"
      echo "  task memory-check   - VÃ©rifier l'usage mÃ©moire"
      echo "  task memory-profile - Profiler pendant refresh"
      echo "  task memory-stress-test - Test de stress mÃ©moire"
      echo "  task cache-status   - Statut du cache Kubernetes"
      echo "  task cache-force-refresh - Forcer refresh du cache"
      echo "  task cache-clear    - Vider le cache (debug)"
      echo "  task cpu-optimization-check - VÃ©rifier optimisations CPU"
      echo ""
      echo "ğŸ›ï¸ Helm:"
      echo "  task helm-template  - Afficher le template"
      echo "  task helm-dry-run   - Test Ã  sec"
